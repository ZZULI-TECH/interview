# 范式

关系数据库中的关系是满足一定要求的，满足不同程度要求的为不同范式。满足最低要求的为第一范式，简称1NF；在第一范式基础上满足进一步要求的为第二范式，依此类推。

对于各种范式之间的关系如下图所示：

![image](https://github.com/ZZULI-TECH/interview/blob/master/images/paradigm.png?raw=true)

## 第一范式

> 数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。如果实体中的某个属性有多个值时，必须拆分为不同的属性。

列的原子性，列不能再分割为其他列。

## 第二范式

> 若R ∈ 1NF，则每一个非主属性完全函数依赖于任何一个候选码，则R ∈ 2NF。

第二范式主要任务是消除部分函数依赖，即在一个表中，不是主键的列必须要完全依赖主键，而不是依赖主键的一部分（主键可以是好几个列）

例如 一个表中有如下字段：

```
student_no,
student_name,
student_age,
class_no,
class_name 
```

其中student_no和class_no是主键，而class_name 依赖于class_no，这就违反了第二范式，需要拆分为两个表，如下：

表一

```
student_no,
student_name,
student_age
```

表二

```
class_no,
class_name 
```

## 第三范式

> 关系模式R<U，F> 中若不存在这样的码X、属性组Y及非主属性Z（Z  Y）, 使得X→Y，Y→Z，成立，则称R<U，F> ∈ 3NF

满足第二范式前提，如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键，这被称作传递依赖于主属性。

第三范式主要解决非主属性的传递依赖问题。即非主属性既不传递依赖于主键，也不部分依赖于主键。

## BCNF

> 设关系模式R<U，F>∈1NF，如果对于R的每个函数依赖X→Y，若Y不属于X，则X必含有候选码，那么R∈BCNF。

任何属性都不能传递依赖任一候选关键字。

## 第四范式

> 关系模式R<U，F>∈1NF，如果对于R的每个非平凡多值依赖X→→Y（Y  X），X都含有候选码，则R∈4NF。

第四范式是消除表中的多值依赖，也就是说可以减少维护数据一致性的工作。

参考：

- 王珊，数据库系统概论（第5版）
- [数据库范式那些事](http://www.cnblogs.com/CareySon/archive/2010/02/16/1668803.html)